using UnityEngine;
using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;

// Assuming WheelChairInputs is a class generated by Unity's Input System
// If not, you might need to define it or adjust input handling.
// For this example, I'll assume it's similar to what your provided code implies.
// public class WheelChairInputs { /* ... your input actions ... */ }
// public class ActuatorComponent : MonoBehaviour { /* ... base class if any ... */ }


public class WheelChairControls : MonoBehaviour // Or : ActuatorComponent if that's your base
{
    WheelChairInputs inputs;

    [Header("Wheel Configuration")]
    [SerializeField]
    Rigidbody rightWheel;

    [SerializeField]
    Rigidbody leftWheel;

    [SerializeField]
    float torqueScale = 100f; // Default torque scale

    [Header("UDP Configuration")]
    [SerializeField]
    private int udpPort = 11000; // Port to listen on

    // --- UDP Network Variables ---
    private Thread udpReceiveThread;
    private UdpClient udpClient;
    private IPEndPoint remoteEndPoint;
    private volatile bool udpDataReceived = false;
    private volatile float udpLeftWheelTorque = 0f;
    private volatile float udpRightWheelTorque = 0f;
    private object lockObject = new object(); // For thread-safe access to UDP data

    private void Awake()
    {
        inputs = new WheelChairInputs(); // Assuming this is correctly set up from your example
        inputs.Enable();

        // Initialize UDP
        try
        {
            remoteEndPoint = new IPEndPoint(IPAddress.Any, udpPort);
            udpClient = new UdpClient(remoteEndPoint);
            Debug.Log($"UDP Listener started on port {udpPort}");

            udpReceiveThread = new Thread(new ThreadStart(ReceiveData));
            udpReceiveThread.IsBackground = true; // Ensure thread closes when Unity exits
            udpReceiveThread.Start();
        }
        catch (Exception e)
        {
            Debug.LogError($"UDP Initialization failed: {e.Message}");
            udpClient = null; // Ensure it's null if setup failed
        }
    }

    // Property to get torque scale, considering shift key for reversal
    float KeyboardTorqueScale => inputs.Keyboard.Shift.IsPressed() ? -torqueScale : torqueScale;

    private void FixedUpdate()
    {
        // --- Keyboard Controls ---
        bool keyboardInputActive = false;
        float keyboardLeftTorque = 0f;
        float keyboardRightTorque = 0f;

        if (inputs.Keyboard.Right.IsPressed())
        {
            // print("Keyboard Right!");
            keyboardRightTorque = KeyboardTorqueScale;
            keyboardInputActive = true;
        }

        if (inputs.Keyboard.Left.IsPressed())
        {
            // print("Keyboard Left!");
            keyboardLeftTorque = -KeyboardTorqueScale; // Assuming opposite torque for left wheel with "Left" key
            keyboardInputActive = true;
        }

        // --- UDP Controls ---
        float currentUdpLeft = 0f;
        float currentUdpRight = 0f;
        bool udpActive = false;

        lock (lockObject) // Thread-safe access
        {
            if (udpDataReceived)
            {
                currentUdpLeft = udpLeftWheelTorque;
                currentUdpRight = udpRightWheelTorque;
                udpActive = true;
                // Optional: Reset flag if you only want to apply UDP input once per received message
                // udpDataReceived = false;
            }
        }

        // --- Apply Torque ---
        // Priority: If UDP data is active, use it. Otherwise, use keyboard.
        // You can change this logic (e.g., add them, average them, etc.)

        if (udpActive)
        {
            // Apply UDP torque (assuming UDP values are already scaled or are direct torque values)
            // If UDP values are normalized (-1 to 1), multiply by torqueScale
            leftWheel.AddTorque(-leftWheel.transform.right * currentUdpLeft * torqueScale, ForceMode.Acceleration);
            rightWheel.AddTorque(rightWheel.transform.right * currentUdpRight * torqueScale, ForceMode.Acceleration);
            if (currentUdpLeft != 0 || currentUdpRight != 0)
            {
                // print($"UDP Control: Left={currentUdpLeft}, Right={currentUdpRight}");
            }
        }
        else if (keyboardInputActive)
        {
            if (keyboardLeftTorque != 0)
            {
                leftWheel.AddTorque(leftWheel.transform.right * keyboardLeftTorque, ForceMode.Acceleration);
            }
            if (keyboardRightTorque != 0)
            {
                rightWheel.AddTorque(rightWheel.transform.right * keyboardRightTorque, ForceMode.Acceleration);
            }
        }
    }

    private void ReceiveData()
    {
        if (udpClient == null) return;

        try
        {
            while (true)
            {
                byte[] data = udpClient.Receive(ref remoteEndPoint);
                string message = Encoding.ASCII.GetString(data);
                // Debug.Log($"UDP Received: {message} from {remoteEndPoint}");

                // Expected format: "left_value,right_value" (e.g., "0.5,1.0")
                string[] parts = message.Split(',');
                if (parts.Length == 2)
                {
                    if (float.TryParse(parts[0], out float receivedLeft) &&
                        float.TryParse(parts[1], out float receivedRight))
                    {
                        lock (lockObject) // Thread-safe update
                        {
                            udpLeftWheelTorque = receivedLeft;
                            udpRightWheelTorque = receivedRight;
                            udpDataReceived = true;
                        }
                    }
                    else
                    {
                        Debug.LogWarning($"UDP: Could not parse torque values from message: {message}");
                    }
                }
                else
                {
                    Debug.LogWarning($"UDP: Received malformed message (expected 2 parts, got {parts.Length}): {message}");
                }
            }
        }
        catch (SocketException e)
        {
            // 10004 is the error code for WSAEINTR (interrupted function call)
            // This typically happens when the socket is closed, so we can ignore it during shutdown.
            if (e.SocketErrorCode != System.Net.Sockets.SocketError.Interrupted)
            {
                Debug.LogError($"UDP Receive SocketException: {e.Message} (Error Code: {e.SocketErrorCode})");
            }
        }
        catch (ThreadAbortException)
        {
            Debug.Log("UDP Receive Thread aborted.");
        }
        catch (Exception e)
        {
            Debug.LogError($"UDP Receive Exception: {e.Message}");
        }
    }

    private void OnEnable()
    {
        inputs.Enable();
        // UDP client is started in Awake and thread runs, no specific OnEnable action needed for UDP here
        // unless you stopped it in OnDisable and want to restart.
    }

    private void OnDisable()
    {
        inputs.Disable();
        // It's generally better to close sockets and abort threads in OnDestroy or OnApplicationQuit
        // as OnDisable can be called multiple times if the object is deactivated and reactivated.
    }

    private void OnDestroy()
    {
        CleanUpUDP();
    }

    private void OnApplicationQuit()
    {
        CleanUpUDP();
    }

    private void CleanUpUDP()
    {
        if (udpReceiveThread != null && udpReceiveThread.IsAlive)
        {
            udpReceiveThread.Abort(); // Request thread termination
            // udpReceiveThread.Join(); // Optionally wait for it to finish
            Debug.Log("UDP Receive Thread aborted on cleanup.");
        }

        if (udpClient != null)
        {
            udpClient.Close();
            udpClient = null;
            Debug.Log("UDP Client closed.");
        }
    }
}
