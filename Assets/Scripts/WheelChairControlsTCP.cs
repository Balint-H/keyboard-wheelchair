using UnityEngine;
using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.IO; // Required for StreamReader

// Assuming WheelChairInputs is a class generated by Unity's Input System
// If not, you might need to define it or adjust input handling.
// public class WheelChairInputs { /* ... your input actions ... */ }
// public class ActuatorComponent : MonoBehaviour { /* ... base class if any ... */ }


public class WheelChairControlsTCP : MonoBehaviour // Or : ActuatorComponent if that's your base
{
    WheelChairInputs inputs;

    [Header("Wheel Configuration")]
    [SerializeField]
    Rigidbody rightWheel;

    [SerializeField]
    Rigidbody leftWheel;

    [SerializeField]
    float torqueScale = 100f; // Default torque scale

    [Header("TCP Configuration")]
    [SerializeField]
    private int tcpPort = 11001; // Port to listen on for TCP connections

    // --- TCP Network Variables ---
    private Thread tcpListenerThread;
    private TcpListener tcpListener;
    private TcpClient connectedTcpClient;
    private NetworkStream networkStream;
    private StreamReader streamReader; // For easier string reading
    private volatile bool tcpDataReceived = false;
    private volatile float tcpLeftWheelTorque = 0f;
    private volatile float tcpRightWheelTorque = 0f;
    private object lockObject = new object(); // For thread-safe access to TCP data
    private volatile bool isRunning = true; // To control the listener loop

    private void Awake()
    {
        inputs = new WheelChairInputs(); // Assuming this is correctly set up
        inputs.Enable();

        // Initialize TCP Listener
        try
        {
            tcpListener = new TcpListener(IPAddress.Any, tcpPort);
            tcpListenerThread = new Thread(new ThreadStart(ListenForIncomingRequests));
            tcpListenerThread.IsBackground = true; // Ensure thread closes when Unity exits
            tcpListenerThread.Start();
            Debug.Log($"TCP Listener started on port {tcpPort}. Waiting for a client connection...");
        }
        catch (Exception e)
        {
            Debug.LogError($"TCP Initialization failed: {e.Message}");
            tcpListener = null; // Ensure it's null if setup failed
        }
    }

    // Property to get torque scale, considering shift key for reversal
    float KeyboardTorqueScale => inputs.Keyboard.Shift.IsPressed() ? -torqueScale : torqueScale;

    private void FixedUpdate()
    {
        // --- Keyboard Controls ---
        bool keyboardInputActive = false;
        float keyboardLeftTorque = 0f;
        float keyboardRightTorque = 0f;

        if (inputs.Keyboard.Right.IsPressed())
        {
            keyboardRightTorque = KeyboardTorqueScale;
            keyboardInputActive = true;
        }

        if (inputs.Keyboard.Left.IsPressed())
        {
            keyboardLeftTorque = -KeyboardTorqueScale;
            keyboardInputActive = true;
        }

        // --- TCP Controls ---
        float currentTcpLeft = 0f;
        float currentTcpRight = 0f;
        bool tcpActive = false;

        lock (lockObject) // Thread-safe access
        {
            if (tcpDataReceived)
            {
                currentTcpLeft = tcpLeftWheelTorque;
                currentTcpRight = tcpRightWheelTorque;
                tcpActive = true;
                // Optional: Reset flag if you only want to apply TCP input once per received message
                // tcpDataReceived = false;
            }
        }

        // --- Apply Torque ---
        // Priority: If TCP data is active, use it. Otherwise, use keyboard.
        if (tcpActive)
        {
            // Apply TCP torque (assuming TCP values are normalized -1 to 1)
            leftWheel.AddTorque(-leftWheel.transform.right * currentTcpLeft * torqueScale, ForceMode.Acceleration);
            rightWheel.AddTorque(rightWheel.transform.right * currentTcpRight * torqueScale, ForceMode.Acceleration);
            // if (currentTcpLeft != 0 || currentTcpRight != 0)
            // {
            //     // Debug.Log($"TCP Control: Left={currentTcpLeft}, Right={currentTcpRight}");
            // }
        }
        else if (keyboardInputActive)
        {
            if (keyboardLeftTorque != 0)
            {
                leftWheel.AddTorque(leftWheel.transform.right * keyboardLeftTorque, ForceMode.Acceleration);
            }
            if (keyboardRightTorque != 0)
            {
                rightWheel.AddTorque(rightWheel.transform.right * keyboardRightTorque, ForceMode.Acceleration);
            }
        }
    }

    private void ListenForIncomingRequests()
    {
        if (tcpListener == null) return;

        try
        {
            tcpListener.Start();

            while (isRunning)
            {
                if (connectedTcpClient == null || !connectedTcpClient.Connected)
                {
                    if (connectedTcpClient != null)
                    {
                        CleanUpClientConnection();
                        Debug.Log("TCP Client disconnected. Waiting for new connection...");
                    }
                    // Blocking call, waits for a new client
                    Debug.Log("TCP Listener: Waiting for a client to connect...");
                    connectedTcpClient = tcpListener.AcceptTcpClient();
                    networkStream = connectedTcpClient.GetStream();
                    streamReader = new StreamReader(networkStream, Encoding.ASCII); // Use StreamReader
                    Debug.Log($"TCP Client connected: {((IPEndPoint)connectedTcpClient.Client.RemoteEndPoint).Address}");
                }

                // Handle connected client
                if (networkStream != null && networkStream.CanRead)
                {
                    try
                    {
                        // Using StreamReader for line-based reading, assuming messages end with a newline
                        string clientMessage = streamReader.ReadLine();
                        if (clientMessage != null) // ReadLine returns null if the connection is closed
                        {
                            // Debug.Log($"TCP Received: {clientMessage}");

                            // Expected format: "left_value,right_value" (e.g., "0.5,1.0")
                            string[] parts = clientMessage.Split(',');
                            if (parts.Length == 2)
                            {
                                if (float.TryParse(parts[0], out float receivedLeft) &&
                                    float.TryParse(parts[1], out float receivedRight))
                                {
                                    lock (lockObject) // Thread-safe update
                                    {
                                        tcpLeftWheelTorque = receivedLeft;
                                        tcpRightWheelTorque = receivedRight;
                                        tcpDataReceived = true;
                                    }
                                }
                                else
                                {
                                    Debug.LogWarning($"TCP: Could not parse torque values from message: {clientMessage}");
                                }
                            }
                            else
                            {
                                Debug.LogWarning($"TCP: Received malformed message (expected 2 parts, got {parts.Length}): {clientMessage}");
                            }
                        }
                        else // Client disconnected
                        {
                            CleanUpClientConnection(); // Clean up and prepare for a new connection
                        }
                    }
                    catch (IOException ex) // Could happen if client disconnects abruptly
                    {
                        Debug.LogWarning($"TCP IOException during read: {ex.Message}. Client might have disconnected.");
                        CleanUpClientConnection();
                    }
                    catch (ObjectDisposedException) // Stream might be closed
                    {
                        Debug.LogWarning("TCP NetworkStream was disposed. Client might have disconnected.");
                        CleanUpClientConnection();
                        // No need to break, the outer loop will attempt to accept a new client
                    }
                }
                else
                {
                    // If no client or not connected, pause briefly to avoid tight loop if AcceptTcpClient is non-blocking for some reason
                    // or if we are between connections.
                    Thread.Sleep(100);
                }
            }
        }
        catch (SocketException socketException)
        {
            if (isRunning) // Only log if we weren't intentionally stopping
            {
                Debug.LogError($"TCP SocketException in Listener: {socketException.Message} (Error Code: {socketException.SocketErrorCode})");
            }
        }
        catch (ThreadAbortException)
        {
            Debug.Log("TCP Listener Thread aborted.");
        }
        catch (Exception e)
        {
            if (isRunning)
            {
                Debug.LogError($"TCP Listener Exception: {e.Message}");
            }
        }
        finally
        {
            CleanUpClientConnection();
            if (tcpListener != null)
            {
                tcpListener.Stop();
                tcpListener = null;
                Debug.Log("TCP Listener stopped.");
            }
        }
    }


    private void CleanUpClientConnection()
    {
        lock (lockObject)
        {
            tcpDataReceived = false; // Reset data flag when client disconnects
        }

        if (streamReader != null)
        {
            streamReader.Close();
            streamReader = null;
        }
        if (networkStream != null)
        {
            networkStream.Close();
            networkStream = null;
        }
        if (connectedTcpClient != null)
        {
            connectedTcpClient.Close();
            connectedTcpClient = null;
        }
    }


    private void OnEnable()
    {
        inputs.Enable();
        // TCP listener is started in Awake and thread runs.
        // If you stop/start it in OnDisable/OnEnable, you'll need more logic here.
    }

    private void OnDisable()
    {
        inputs.Disable();
        // Consider if you want to stop the listener on disable.
        // Usually, OnDestroy/OnApplicationQuit is better for cleanup.
    }

    private void OnDestroy()
    {
        CleanUpNetwork();
    }

    private void OnApplicationQuit()
    {
        CleanUpNetwork();
    }

    private void CleanUpNetwork()
    {
        isRunning = false; // Signal the listening thread to stop

        CleanUpClientConnection(); // Clean up any active client connection

        if (tcpListener != null)
        {
            // Closing the listener will cause AcceptTcpClient to throw an exception if it's blocking,
            // which helps the thread to exit its loop.
            tcpListener.Stop();
            tcpListener = null;
            Debug.Log("TCP Listener stopped on cleanup.");
        }

        if (tcpListenerThread != null && tcpListenerThread.IsAlive)
        {
            // Give the thread a moment to exit gracefully after tcpListener.Stop()
            if (!tcpListenerThread.Join(500)) // Wait up to 500ms
            {
                // If it's still alive, then abort.
                tcpListenerThread.Abort();
                Debug.Log("TCP Listener Thread aborted on cleanup.");
            }
            else
            {
                Debug.Log("TCP Listener Thread joined gracefully.");
            }
            tcpListenerThread = null;
        }
        Debug.Log("TCP Network resources cleaned up.");
    }
}